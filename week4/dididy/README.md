# 4주차 문제

## 영어 끝말잇기 - Lv2

n명의 사람들이 끝말잇기를 할 때 중복된 단어를 말하거나 끝말잇기 규칙에 어긋나면 누가 몇번째 순서에 실수를 했는지 출력하는 문제였다.

그냥 n개의 배열이 존재하는 2차원 배열을 만들어서 순서에 맞게 순회하도록 하였다. 맨 처음은 넘어가도록 하였고 각 싸이클의 마지막 단어를 기억해서 각 싸이클의 첫번째에 기억한 단어와 비교할 수 있도록 변수를 만들었다. 끝말잇기 규칙에 부합하는지를 체크하는 함수를 이용해 실패한 경우 해당 index를 출력하면 된다.

다 풀고보니 중복된 단어를 체크하지 않았다. 이부분은 해싱으로 구현했다.

## 튜플 - Lv2

삽질을 조금 하긴 했지만 생각보다 쉽게 푼 문제였다. 정규표현식으로 bracket을 모두 제거하고 ','를 기준으로 split해서 배열을 만든 뒤 해당 숫자가 몇개가 나왔는지를 객체를 만들어 체크하고 가장 많이 등장한 숫자부터 key를 출력하도록 하면 풀리는 문제이다.

reduce를 이용해 배열에 등장한 숫자가 몇번 반복되는지 객체를 만들어서 풀 경우 value 기준으로 정렬하는 방법을 사용해봤지만 이상하게 잘 되지 않았다. 어쩔 수 없이 value로 key를 찾는 함수를 만들어서 해결하고자 했는데 당연히 O(N)만큼 추가적으로 탐색하므로 시간초과가 났다.

객체로 되어있는 부분을 Map으로 변경했다. Map의 경우 Array.from()을 이용해 value를 기준으로 sort가 가능했고 모든 테스트케이스를 통과했다. 다음엔 value 기준으로 정렬이 필요한 경우 Map을 사용해야겠다.

## 셔틀버스 - Lv3
timetable로 주어진 시간에 대해 시간 문자열을 분 단위로 변환하는 함수를 만들고 각각을 분단위로 변환한 뒤 새로운 배열에 넣어 오름차순 정렬했다.

가장 늦게 탑승하는 시간을 구해야 하므로 n번(셔틀 운행 횟수)만큼 순회하며 마지막 셔틀 시간(9:00로 초기화 함) 보다 작은 시간표의 갯수(예상 탑승 승객의 수)를 구하고 그 갯수가 m보다 작거나 같은 경우 그만큼을 timetable에서 제거하고 m보다 크면 m만큼 제거한다. 마지막 순회를 제외한 순회마다 마지막 셔틀 시간은 기존값에 +t 한다.

만약 순회의 마지막에 예상 탑승 승객의 수가 m보다 크거나 같은 경우 마지막 시간에 -1 한 값을 마지막 셔틀 시간으로 한다. 그게 아니라면 순회시 더한 마지막 셔틀 기준으로 분 단위에서 시간 단위로 변환하면 된다.
