# 3주차 문제
## 수식 최대화 - Lv2
operator의 우선순위 순서로 가능한 순열 6가지에 대해 각각 생각하면 된다.

정규 표현식으로 expression의 operator와 number를 나눠서 배열에 저장하고 연산자 순서대로 연산을 하도록 하게끔 하는 과정을 반복한 절댓값이 가장 큰 경우를 출력하면 된다.


## 큰 수 만들기 - Lv2
이 문제는 그리다 문제이다. 가장 큰 값을 지속적으로 선택해서 k 만큼 제외된 수 중 가장 큰 수를 만들어야만 한다.

numbers 배열의 수를 분해하여 forEach로 순회해나간다. 만약 k가 0보다 크고 스택의 마지막 값 보다 numbers 배열의 현재 index 값이 크다면 해당 조건이 성립할 동안 stack의 pop 연산을 수행하고 k의 길이를 pop 연산 한 만큼 줄인다. 앞서 pop 한 수가 제외된 수가 되며 반복문이 끝나면 현재 index의 값을 stack에 넣는다. 이것을 반복하면 k 만큼 제외된 수 중 가장 큰 수를 구할 수 있다.

하지만 이렇게 풀 경우 후처리를 하지 않으면 12번 테스트 케이스를 통과하지 못한다. 해당 테스트케이스의 형태는 number에 "54321", k에 4가 들어가는 형태이다. 이 경우 pop 연산이 전혀 일어날 수 없으므로 기대한 값인 "5"가 출력되지 않고 "54321"이 출력되게 된다. 따라서 이에 대한 후처리를 해줘야만 하는데 k가 줄어들지 않은 상황이므로 그만큼 slice를 함으로서 해결할 수 있다.


## 합승 택시 요금 - Lv3
최단 경로니까 당연히 다익스트라 써서 풀어야 한다고 생각했다. 풀다 보니 복잡해지고 안 풀려서 찾아보니 플로이드 와살을 사용하면 간단하게 풀리는 문제였다.

다익스트라는 한 정점의 최단거리를 구하는 것이지만 플로이드 와살은 모든 정점에서 모든 정점으로의 최단거리를 구할 수 있다. 따라서 다익스트라로 해당 문제를 풀게 되면 각 정점을 순회하며 계산하는 방식으로 구현하면 된다. 다익스트라를 사용한다면 코드는 좀 복잡해지긴 하겠지만 시간 복잡도나 공간 복잡도 측면에서 플로이드와 살보다는 효율적일 것이다.
