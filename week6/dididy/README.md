# 5주차 문제


## 기능 개발 - Lv2
buffer라는 리스트를 추가로 만들어 prgresses의 각 원소의 남은 퍼센티지를 속도로 나눈 올림 값을 순서대로 넣었다. max 값을 buffer의 첫 번째 값으로 정의하고 forEach로 순회를 해서 현재 값이 max보다 작은 경우 count를 1씩 증가시켰고 max보다 큰 경우 현재까지의 count를 answer에 넣는 방식으로 해결했다.

제출할 당시 시간 복잡도는 O(N)이라 시간 초과는 발생하지 않을 거라 예상했다. 아직 파악하지 못한 예외 처리할 부분이 있을 줄 알았지만 제출하고 보니 테스트케이스를 모두 통과하였다.

마지막 count에 대해 forEach 문밖에서 push를 하고 있는데 이번 주에 할당된 문제 다 풀고 리팩토링할 때 손봐야겠다.

## 다리를 지나는 트력 - Lv2
시간이 증가함에 따라 트럭의 이동시켜 도착하도록 만들고 현재 다리 위의 무게(currentWeight)를 기준으로 truck_weights queue에 들어 있는 트럭을 출발시키는 등 각각의 경우를 조건을 걸어 처리하였다.

먼저 시간이 증가하는 것에 따라 생각하는 게 좋겠다 싶어 while loop을 만들었고 반복문이 실행될 때마다 time이라는 변수를 1씩 증가하도록 하였다. 다리 위의 무게(currentWeight)가 0이 되면 종료하도록 조건을 걸었다.

ing이라는 리스트를 다리 길이(bridge_length) 만큼 만들어 새로운 트럭이 들어가면 트럭 무게에 해당하는 값을 unshift 메서드로 넣도록 하였다.

while loop이 돌면서 ing에 가장 처음에 넣은 값을 pop 해서 다리 위의 무게(currentWeight)에서 뺀 값을 currentWeight에 반영하였다.

현재 다리 위의 무게(currentWeight)에 추가적인 트럭이 진입할 수 있는지를 파악할 수 있도록 currentTruck의 값에 truck_wieghts의 0번째 원소를 shift 해서 currentTruck에 대입하였고 진입할 수 없는 경우 않는 경우 shift 한 값을 unshift를 통해 원래의 리스트로 복구시켰다.

다리 위 상황이 다음 트럭이 진입할 수 있는 상황이라면 currentTruck 값을 unshift를 통해 ing 리스트에 추가하였고 여유가 없다면 0을 추가하였다.

이 과정을 반복하여 몇 초의 시간이 소요되는지를 return 하도록 구현하였다.

Python dequeue의 popleft처럼 JS에서는 shift를 사용할 수 있다. unshift를 이용하면 반대 방향에 특정 원소를 push를 하는 것도 가능했다. 이를 활용해서 문제를 풀긴 했는데 다른 분들 풀이 설명을 보니 이렇게 풀면 모든 테스트케이스를 통과하긴 하지만 시간 복잡도 이슈가 있다고 한다.

shift 자체가 O(N)의 시간복잡도를 가지고 있어서 반복적으로 사용되는 경우 reverse 해서 스택처럼 쓰는 게 시간복잡도 상으로 좋다고 한다. 추후에 이렇게 리팩토링해야겠다.

## 가장 먼 노드 - Lv3
그래프 순회로 가장 긴 간선을 가지는 노드의 개수를 구하는 문제이다. bfs를 이용해 풀어야 하며 그 과정에서 queue를 활용해야 한다.

visited 배열을 만들어 기준 노드와 거리를 넣는 방식으로 문제를 해결하였다. 마지막에 최대값에 해당하는 길이가 몇개인지만 체크하면 된다.

queue에 담긴 직전 접근한 노드의 정보를 node 변수에 담아 접근 가능 여부, 접근했는지를 체크하여 각각의 경우에 맞게 처리해 준다.

접근 가능한 경우에 접근했던 경우 접근하지 았았던 경우를 생각해보자.

1. 접근 했다면 다음 순회로 넘어간다.
2. 접근 안 했다면 vsisted의 위치 값에 1을 더해준다.

두 경우 모두 edge의 앞부분을 splice로 떼어내고 그만큼 index를 재정의한다. 이 과정을 모든 노드에 접근할 때(edge의 길이가 0이 될 때까지)까지 반복하면 된다.